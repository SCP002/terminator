package main

import (
	"flag"
	"os"

	"golang.org/x/sys/windows"
)

/*
	Simple command line program which recieves PID of the process
	to send Ctrl + C signal to, and terminates together with the
	target process.

	Meant to be built with -ldflags -H=windowsgui build options to
	not to flash with the console during it's short life time and
	to not to call "FreeConsole" for nothing.

	Exit codes:
	1          - Wrong PID. Either not specified or -1.
	2          - Calling process is already attached to a console.
	3          - Target process does not have a console.
	4          - Target process does not exist.
	5          - AttachConsole failed for an unknown reason.
	6          - SetConsoleCtrlHandler failed.
	7          - GenerateConsoleCtrlEvent failed.
	3221225786 - STATUS_CONTROL_C_EXIT, the application terminated
	             as a result of a Ctrl + C, expected value.
*/

// Own exit codes.
const (
	exitWrongPid int = iota + 1

	exitCallerAlreadyAttached
	exitTargetHaveNoConsole
	exitProcessDoesNotExist
	exitAttachFailed

	exitEnableCtrlCFailed
	exitSendCtrlCFailed
)

// Windows constants.
const (
	NULL                  uintptr = 0
	FALSE                 uintptr = 0
	STATUS_CONTROL_C_EXIT int     = 3221225786
)

func main() {
	// Using -h flag to display help won't work as we don't have a console and
	// attach to the foreign one. Usage messages are placeholders intended to
	// be read here.
	var pid int
	flag.IntVar(&pid, "pid", -1, "Process identifier of the console to attach to")
	flag.Parse()

	// Negative process identifiers are disallowed in Windows,
	// using it as a default value check.
	if pid == -1 {
		os.Exit(exitWrongPid)
	}

	k32 := windows.MustLoadDLL("kernel32.dll")
	defer k32.Release()

	// Attach to the target process console (form a console process group).
	k32Proc := k32.MustFindProc("AttachConsole")
	r1, _, err := k32Proc.Call(uintptr(pid))
	if r1 == 0 {
		if err == windows.ERROR_ACCESS_DENIED {
			os.Exit(exitCallerAlreadyAttached)
		}
		if err == windows.ERROR_INVALID_HANDLE {
			os.Exit(exitTargetHaveNoConsole)
		}
		if err == windows.ERROR_INVALID_PARAMETER {
			os.Exit(exitProcessDoesNotExist)
		}
		os.Exit(exitAttachFailed)
	}

	// Enable Ctrl + C processing (just in case).
	k32Proc = k32.MustFindProc("SetConsoleCtrlHandler")
	r1, _, _ = k32Proc.Call(NULL, FALSE)
	if r1 == 0 {
		os.Exit(exitEnableCtrlCFailed)
	}

	// Send Ctrl + C signal to the current console process group.
	k32Proc = k32.MustFindProc("GenerateConsoleCtrlEvent")
	// Not using CTRL_BREAK_EVENT (which can't be ignored by the process) or
	// else, if our parent process shares the same console with this process,
	// we will stop the parent and SetConsoleCtrlHandler can't prevent it.
	// Parameter is 0 (all processes attached to the current console) but not
	// pid, or else it will fail to send a signal to consoles separate from
	// the current.
	r1, _, _ = k32Proc.Call(windows.CTRL_C_EVENT, uintptr(0))
	if r1 == 0 {
		os.Exit(exitSendCtrlCFailed)
	}

	// If this program runs properly, we should never reach this point, rather
	// exit with STATUS_CONTROL_C_EXIT exit code generated by the system itself
	// (instantly if binary was built with -ldflags -H=windowsgui).
	// Exiting with proper exit code manually as a fallback.
	os.Exit(STATUS_CONTROL_C_EXIT)
}
