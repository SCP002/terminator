package main

import (
	"flag"
	"os"

	"golang.org/x/sys/windows"
)

/*
	Simple command line program which recieves PID of the process
	to send Ctrl + C signal to, and terminates together with the
	target process.

	Meant to be built with -ldflags -H=windowsgui build options to
	not to flash with the console during it's short life time and
	to not to call "FreeConsole" for nothing.

	Exit codes:
	1          - Wrong PID.
	2          - AttachConsole failed.
	3          - SetConsoleCtrlHandler failed.
	4          - GenerateConsoleCtrlEvent failed.
	3221225786 - STATUS_CONTROL_C_EXIT, the application terminated as a result of a Ctrl + C, expected value.
*/

// Own exit codes
const (
	exitWrongPid int = iota + 1
	exitAttachFailed
	exitEnableCtrlCFailed
	exitSendCtrlCFailed
)

// Windows constants
const (
	NULL                  uintptr = 0
	FALSE                 uintptr = 0
	STATUS_CONTROL_C_EXIT int     = 3221225786
)

func main() {
	var pid int
	flag.IntVar(&pid, "pid", -1, "Process identifier of the console to attach to")
	flag.Parse()

	// Negative process identifiers are disallowed in Windows,
	// using it as a default value check.
	if pid == -1 {
		os.Exit(exitWrongPid)
	}

	dll := windows.MustLoadDLL("kernel32.dll")
	defer dll.Release()

	// Attach to the target process console (form a console process group).
	f := dll.MustFindProc("AttachConsole")
	r1, _, _ := f.Call(uintptr(pid))
	if r1 == 0 {
		os.Exit(exitAttachFailed)
	}

	// Enable Ctrl + C processing (just in case).
	f = dll.MustFindProc("SetConsoleCtrlHandler")
	r1, _, _ = f.Call(NULL, FALSE)
	if r1 == 0 {
		os.Exit(exitEnableCtrlCFailed)
	}

	// Send Ctrl + C signal to the current console process group.
	f = dll.MustFindProc("GenerateConsoleCtrlEvent")
	// Not using CTRL_BREAK_EVENT (which can't be ignored by the process) or
	// else, if our parent process shares the same console with this process,
	// we will stop the parent and SetConsoleCtrlHandler can't protect it.
	// Parameter is 0 (all processes attached to the current console) but not
	// pid, or else it will fail to send a signal to consoles separate from
	// the current.
	r1, _, _ = f.Call(windows.CTRL_C_EVENT, uintptr(0))
	if r1 == 0 {
		os.Exit(exitSendCtrlCFailed)
	}

	// If this program runs properly, we should never reach this point, rather
	// exit with STATUS_CONTROL_C_EXIT exit code generated by the system itself.
	// Exiting with proper exit code manually as a fallback.
	os.Exit(STATUS_CONTROL_C_EXIT)
}
